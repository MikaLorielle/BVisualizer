<!DOCTYPE html>
<html lang="en" class="bg-black">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Smooth Mesh Bars Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: black;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: default;
        }

        #controlPanel {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 0.5rem;
            padding: 1rem;
            width: 280px;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            box-shadow: 0 0 15px rgba(255 255 255 / 0.2);
            user-select: none;
            z-index: 100;
            display: none;
        }

        #controlPanel label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 600;
            font-size: 0.9rem;
        }

        #controlPanel .color-field {
            width: 100%;
            height: 2.25rem;
            margin-bottom: 1rem;
            border-radius: 0.3rem;
            overflow: hidden;
            position: relative;

            input[type=color] {
                --color-border-width: 0.35rem;

                top: calc(var(--color-border-width) * -1);
                left: calc(var(--color-border-width) * -1);
                width: calc(100% + (var(--color-border-width)) * 2);
                height: calc(100% + (var(--color-border-width)) * 2);
                position: absolute;
                border: none;
                cursor: pointer;
                padding: 0;
                background: transparent;
                display: block;


                &::after {
                    display: none;
                }
            }
        }

        #controlPanel input[type=text] {
            width: 3rem;
            text-align: center;
            background: #222;
            color: white;
            border: 1px solid #555;
            border-radius: 0.25rem;
            padding: 0.25rem;
            font-size: 1rem;
        }

        #controlPanel small {
            font-size: 0.75rem;
            color: #bbb;
            user-select: none;
        }

        #footerNote {
            font-size: 0.8rem;
            margin-top: 0.5rem;
            color: #888;
            text-align: center;
            user-select: none;
        }

        #audioName {
            position: fixed;
            color: white;
            font-family: monospace;
            user-select: none;
            z-index: 100;
            top: unset;
            left: unset;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .glow-title {
            font-size: 3.5rem;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(90deg, #ff00ff, #ff1493, #00ffff);
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            display: inline-block;
            animation: glowPulse 2s infinite alternate, textGradient 4s ease infinite alternate;
            text-shadow: 0 0 10px #ff00ff63, 0 0 20px #ff00ff71, 0 0 40px #ff149160;
            transition: transform 0.3s ease;
        }

        .glow-title:hover {
            transform: scale(1.05);
        }

        @keyframes glowPulse {
            0% {
                text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff1493, 0 0 20px #ff1493;
            }

            100% {
                text-shadow: 0 0 15px #ff00ff, 0 0 30px #ff00ff, 0 0 45px #ff1493;
            }
        }

        @keyframes textGradient {
            0% {
                background-position: 0% center;
            }

            100% {
                background-position: 200% center;
            }
        }
    </style>
</head>

<body>
    <canvas id="visualizer"></canvas>
    <div id="audioName" class="glow-title"
        style="position: fixed; top: 1rem; left: 1rem; user-select: none; z-index: 100;">
        audio
    </div>
    <audio id="audio" crossorigin="anonymous"></audio>
    <div id="controlPanel" aria-label="Control Panel">
        <div>
            <label for="bgTopColor">Background Top Color</label>
            <div class="color-field">
                <input type="color" id="bgTopColor" />
            </div>
        </div>
        <div>
            <label for="bgBottomColor">Background Bottom Color</label>
            <div class="color-field">
                <input type="color" id="bgBottomColor" />
            </div>
        </div>
        <div>
            <label for="waveColor1">Wave Gradient Color 1</label>
            <div class="color-field">
                <input type="color" id="waveColor1" />
            </div>
        </div>
        <div>
            <label for="waveColor2">Wave Gradient Color 2</label>
            <div class="color-field">
                <input type="color" id="waveColor2" />
            </div>
        </div>
        <div>
            <label for="waveColor3">Wave Gradient Color 3</label>
            <div class="color-field">
                <input type="color" id="waveColor3" />
            </div>
        </div>
        <div style="margin-bottom: 1rem;">
            <label for="audioFileInput" id="audioFileInputLabel"
                class="inline-block cursor-pointer select-none font-semibold bg-gradient-to-r from-purple-500 via-purple-700 to-indigo-700 text-white py-2 px-5 rounded-md shadow-md transition-colors transition-transform duration-200 text-base text-center w-full">
                <span id="audioFileInputLabelText" class="text-base">Import Song</span>
            </label>
            <input type="file" id="audioFileInput" accept="audio/*" class="hidden" />

            <button id="resetSettingsBtn" type="button"
                class="block w-full mt-3 bg-gradient-to-r from-cyan-400 via-indigo-600 to-purple-700 text-white font-semibold py-2 px-5 rounded-md shadow-md transition-colors transition-transform duration-200 text-base text-center cursor-pointer">
                Reset Settings
            </button>
        </div>
        <div style="margin-top: 1rem;">
            <label>Keybindings</label>
            <div style="margin-bottom: 0.5rem;">
                <label>Play/Pause:</label>
                <input type="text" id="keyPlayPause"/>
            </div>
            <div style="margin-bottom: 0.5rem;">
                <label>Rewind:</label>
                <input type="text" id="keyRewind"/>
            </div>
            <div style="margin-bottom: 0.5rem;">
                <label>Forward:</label>
                <input type="text" id="keyForward"/>
            </div>
        </div>
        <small>Press <b>F</b> to toggle this panel.</small>


        <script>
            const DEFAULT_VALUES = {
                "bg-top": '#000000',
                "bg-bottom": '#2d0769',
                "wave-1": '#ff6ec4',
                "wave-2": '#9d50bb',
                "wave-3": '#00d2ff',
                "key-play-pause": 'k',
                "key-rewind": 'j',
                "key-forward": 'l'
            };

            /**
             * @type {Record<string, HTMLInputElement>}
             */
            const INPUTS = {
                "bg-top": document.getElementById("bgTopColor"),
                "bg-bottom": document.getElementById("bgBottomColor"),
                "wave-1": document.getElementById("waveColor1"),
                "wave-2": document.getElementById("waveColor2"),
                "wave-3": document.getElementById("waveColor3"),
                "key-play-pause": document.getElementById("keyPlayPause"),
                "key-rewind": document.getElementById("keyRewind"),
                "key-forward": document.getElementById("keyForward"),
            }

            function loadSettings() {
                for (const key in DEFAULT_VALUES) {
                    const value = localStorage.getItem(key);
                    if (value) {
                        if (INPUTS[key].type === "color" || INPUTS[key].type === "text") {
                            INPUTS[key].value = value;
                        }
                    } else {
                        localStorage.setItem(key, DEFAULT_VALUES[key]);
                        if (INPUTS[key].type === "color" || INPUTS[key].type === "text") {
                            INPUTS[key].value = DEFAULT_VALUES[key];
                        }
                    }
                }
            }

            function resetSettings() {
                for (const key in DEFAULT_VALUES) {
                    localStorage.setItem(key, DEFAULT_VALUES[key]);

                    if (INPUTS[key]) {
                        INPUTS[key].value = DEFAULT_VALUES[key];
                        INPUTS[key].dispatchEvent(new Event('input'));
                    }
                }
            }

            loadSettings();
            document.getElementById("resetSettingsBtn").addEventListener("click", resetSettings);

            /**
             * Get a value from localStorage, or return the default value for that key
             *
             * @param {keyof typeof DEFAULT_VALUES} key
             * @return {string}
             */
            function getFromLocalStorage(key) {
                const value = localStorage.getItem(key);
                return value ? value : DEFAULT_VALUES[key] ?? '';
            };

            let visualProgress = 0;
            const canvas = document.getElementById("visualizer");
            const ctx = canvas.getContext("2d");
            let W, H;
            function resize() {
                W = window.innerWidth;
                H = window.innerHeight;
                canvas.width = W;
                canvas.height = H;
            }
            resize();
            window.addEventListener("resize", resize);

            const audioNameDiv = document.getElementById("audioName");
            const audioFileInput = document.getElementById("audioFileInput");
            const audio = document.getElementById("audio");

            audioNameDiv.innerHTML = '<p>No audio loaded</span><p class="text-[1.5rem] mx-auto w-fit">Press F to open panel.</p>';

            audioFileInput.addEventListener("change", (e) => {
                const files = e.target.files;
                if (files.length === 0) return;

                const file = files[0];
                const fileURL = URL.createObjectURL(file);

                audio.pause();
                audio.src = fileURL;
                audio.load();

                audioNameDiv.textContent = file.name;

                if (audioCtx.state === "suspended") {
                    audioCtx.resume();
                }

                audio.play();
            });
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const audioCtx = new AudioContext();
            const source = audioCtx.createMediaElementSource(audio);
            const analyser = audioCtx.createAnalyser();
            source.connect(analyser);
            analyser.connect(audioCtx.destination);

            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const freqArray = new Uint8Array(bufferLength);

            const particles = [];
            const particleCount = 60;

            class Particle {
                constructor() {
                    this.reset();
                }
                reset() {
                    this.x = Math.random() * W;
                    this.y = Math.random() * H;
                    this.size = 0.5 + Math.random() * 1.5;
                    this.speedX = (Math.random() - 0.5) * 0.2;
                    this.speedY = (Math.random() - 0.5) * 0.2;
                    this.alpha = 0.1 + Math.random() * 0.1;
                }
                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    if (this.x < 0 || this.x > W || this.y < 0 || this.y > H) {
                        this.reset();
                    }
                }
                draw(ctx) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(200, 180, 255, ${this.alpha})`;
                    ctx.shadowColor = `rgba(200, 180, 255, ${this.alpha})`;
                    ctx.shadowBlur = 5;
                    ctx.fill();
                }
            }

            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }

            let pointsCount = 60;
            const pointsMin = 20;
            const pointsMax = 150;

            function smoothCurve(ctx, points) {
                if (points.length < 3) {
                    ctx.lineTo(points[0].x, points[0].y);
                    return;
                }
                ctx.moveTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length - 2; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                }
                ctx.quadraticCurveTo(
                    points[points.length - 2].x,
                    points[points.length - 2].y,
                    points[points.length - 1].x,
                    points[points.length - 1].y
                );
            }

            const controlPanel = document.getElementById("controlPanel");
            const bgTopColorInput = document.getElementById("bgTopColor");
            const bgBottomColorInput = document.getElementById("bgBottomColor");
            const waveColor1Input = document.getElementById("waveColor1");
            const waveColor2Input = document.getElementById("waveColor2");
            const waveColor3Input = document.getElementById("waveColor3");

            let bgTopColor = bgTopColorInput.value;
            let bgBottomColor = bgBottomColorInput.value;
            let waveColor1 = waveColor1Input.value;
            let waveColor2 = waveColor2Input.value;
            let waveColor3 = waveColor3Input.value;

            bgTopColorInput.addEventListener("input", (e) => {
                bgTopColor = e.target.value;
                localStorage.setItem("bg-top", bgTopColor);
            });
            bgBottomColorInput.addEventListener("input", (e) => {
                bgBottomColor = e.target.value;
                localStorage.setItem("bg-bottom", bgBottomColor);
            });
            waveColor1Input.addEventListener("input", (e) => {
                waveColor1 = e.target.value;
                localStorage.setItem("wave-1", waveColor1);
            });
            waveColor2Input.addEventListener("input", (e) => {
                waveColor2 = e.target.value;
                localStorage.setItem("wave-2", waveColor2);
            });
            waveColor3Input.addEventListener("input", (e) => {
                waveColor3 = e.target.value;
                localStorage.setItem("wave-3", waveColor3);
            });

            function draw() {
                requestAnimationFrame(draw);
                audioNameDiv.style.left = (W / 2) + "px";
                audioNameDiv.style.top = (H * 0.425) + "px";

                const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
                bgGrad.addColorStop(0, bgTopColor);
                bgGrad.addColorStop(1, bgBottomColor);
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, W, H);

                particles.forEach(p => {
                    p.update();
                    p.draw(ctx);
                });

                analyser.getByteTimeDomainData(dataArray);

                const step = Math.floor(bufferLength / pointsCount);
                const points = [];
                for (let i = 0; i < pointsCount; i++) {
                    const val = dataArray[i * step] / 128.0;
                    const x = (i / (pointsCount - 1)) * W;

                    const y = val * (H * 0.4) / 2 + H * 0.35;
                    points.push({ x, y });
                }

                const waveGradient = ctx.createLinearGradient(0, H * 0.65, W, H);
                waveGradient.addColorStop(0, waveColor1);
                waveGradient.addColorStop(0.5, waveColor2);
                waveGradient.addColorStop(1, waveColor3);

                ctx.lineWidth = 3;
                ctx.strokeStyle = waveGradient;
                ctx.shadowColor = waveGradient;
                ctx.shadowBlur = 25;

                ctx.beginPath();
                smoothCurve(ctx, points);
                ctx.stroke();

                analyser.getByteFrequencyData(freqArray);
                const barCount = 60;
                const maxBarHeight = H * 0.25;
                const barPoints = [];
                const offsetX = 0;
                const stretchPx = 25;

                for (let i = 0; i < barCount; i++) {
                    const value = freqArray[i];
                    const barHeight = (value / 255) * maxBarHeight;

                    const x = offsetX + (i / (barCount - 1)) * (W + stretchPx);
                    const y = H - barHeight;

                    barPoints.push({ x, y });
                }


                const barGradient = ctx.createLinearGradient(0, H * 0.7, 0, H);
                barGradient.addColorStop(0, waveColor3);
                barGradient.addColorStop(0.5, waveColor2);
                barGradient.addColorStop(1, waveColor1);

                ctx.fillStyle = barGradient;
                ctx.shadowColor = barGradient;
                ctx.shadowBlur = 25;

                ctx.beginPath();
                ctx.moveTo(barPoints[0].x, H);

                for (let i = 0; i < barPoints.length - 1; i++) {
                    const cpX = (barPoints[i].x + barPoints[i + 1].x) / 2;
                    const cpY = (barPoints[i].y + barPoints[i + 1].y) / 2;
                    ctx.quadraticCurveTo(barPoints[i].x, barPoints[i].y, cpX, cpY);
                }

                ctx.lineTo(barPoints[barPoints.length - 1].x, H);
                ctx.closePath();
                ctx.fill();
                drawProgressBar();
            }

            const sparkleCount = 30;
            const sparkles = [];
            class Sparkle {
                constructor() {
                    this.reset();
                }
                reset() {
                    this.x = Math.random();
                    this.y = (Math.random() - 0.5) * 10;
                    this.size = 1 + Math.random() * 1.5;
                    this.speed = 0.001 + Math.random() * 0.003;
                    this.alpha = 0.4 + Math.random() * 0.6;
                }
                update() {
                    this.x += this.speed;
                    if (this.x > 1) this.reset();
                }
                draw(ctx, px, py, width) {
                    const drawX = px + this.x * width;
                    const drawY = py + this.y;
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, this.size, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(drawX, drawY, 0, drawX, drawY, this.size * 3);
                    gradient.addColorStop(0, `rgba(255,255,255,${this.alpha})`);
                    gradient.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
            }

            for (let i = 0; i < sparkleCount; i++) {
                sparkles.push(new Sparkle());
            }

            function drawProgressBar() {
                if (!audio.duration) return;

                const margin = 40;
                const barWidth = W * 0.5;
                const barHeight = 16;
                const posX = (W - barWidth) / 2;
                const posY = H * 0.1;

                const targetProgress = audio.currentTime / audio.duration || 0;
                visualProgress += (targetProgress - visualProgress) * 0.1;

                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(posX, posY, barWidth, barHeight, 8);
                ctx.fill();
                ctx.stroke();

                const grad = ctx.createLinearGradient(posX, 0, posX + barWidth, 0);
                grad.addColorStop(0, '#ff6ec4');
                grad.addColorStop(0.5, '#9d50bb');
                grad.addColorStop(1, '#00d2ff');

                ctx.fillStyle = grad;
                ctx.shadowColor = 'rgba(157, 80, 187, 0.7)';
                ctx.shadowBlur = 15;

                ctx.beginPath();
                ctx.roundRect(posX, posY, barWidth * visualProgress, barHeight, 8);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

                sparkles.forEach(s => {
                    s.update();
                    s.draw(ctx, posX, posY + barHeight / 2, barWidth * visualProgress);
                });
            }

            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };

            draw();

            const keyPlayPauseInput = document.getElementById("keyPlayPause");
            const keyRewindInput = document.getElementById("keyRewind");
            const keyForwardInput = document.getElementById("keyForward");

            let keyPlayPause = keyPlayPauseInput.value;
            let keyRewind = keyRewindInput.value;
            let keyForward = keyForwardInput.value;

            document.addEventListener("keydown", (e) => {
                if (e.target.closest("input, textarea, select")) return;

                const key = e.key.toLowerCase();

                if (key === ">") {
                    pointsCount = Math.min(pointsCount + 5, pointsMax);
                } else if (key === "<") {
                    pointsCount = Math.max(pointsCount - 5, pointsMin);
                } else if (key === "f") {
                    controlPanel.style.display = controlPanel.style.display === "none" || controlPanel.style.display === "" ? "block" : "none";
                } else if (key === keyPlayPause) {
                    if (audioCtx.state === "suspended") audioCtx.resume();
                    audio.paused ? audio.play() : audio.pause();
                } else if (key === keyRewind) {
                    audio.currentTime = Math.max(audio.currentTime - 10, 0);
                } else if (key === keyForward) {
                    audio.currentTime = Math.min(audio.currentTime + 10, audio.duration);
                }
            });

            document.getElementById("keyPlayPause").addEventListener("input", (e) => {
                e.target.value = e.target.value.slice(-1);
                keyPlayPause = e.target.value.toLowerCase();
            });

            document.getElementById("keyRewind").addEventListener("input", (e) => {
                keyRewind = e.target.value.toLowerCase();
            });

            document.getElementById("keyForward").addEventListener("input", (e) => {
                keyForward = e.target.value.toLowerCase();
            });

            document.getElementById("keyRewind").addEventListener("input", (e) => {
                e.target.value = e.target.value.slice(-1);
                keyRewind = e.target.value.toLowerCase();
            });

            document.getElementById("keyForward").addEventListener("input", (e) => {
                e.target.value = e.target.value.slice(-1);
                keyForward = e.target.value.toLowerCase();
            });

        </script>
</body>

</html>